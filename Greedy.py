'''
현재 상황에서 지금 당장 좋은것만 고르는 방법
일반적인 그리디 알고리즘은 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구
정당성 분석이 중요 - 가장 좋아보이는 것을 반복적으로 선택해도 최적의 해를 구할 수 있는지 검토
'''

'''
예시 ) 루트노드부터 시작하여 거쳐가는 노드 값의 합을 최대로 만들고 싶습니다.
Q. 최적의 해는 무엇인가요?
5-7-9 = 21
                        5
               7       10          8
        7   5   9     4  3       1   4   5                  
Q. 단순히 가장 큰 값만 고른다면 5-10-4=19
'''
'''
탐욕법으로 얻은 해가 최적의 해가 되는 상황에서, 이를 추론할 수 있어야 풀리도록 제출
대표적인 예시 ) 거스름 돈 문제
- 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문
'''
# 거스름 돈 답안
n = 1260    # 거스름 돈
count = 0

array = [500,100,50,10]

for coin in array :
    count += n // coin      # 해당 화페로 거슬러 줄 수 있는 동전의 개수 세기
    n %= coin

print(count)

# 시간 복잡도
'''
화폐의 종류가 K라고 할 때, 소스코드의 시간 복잡도는 O(K)
거슬러줘야 하는 금액과는 무관하며, 동전의 총 종류에만 영향을 받음
'''
  
'''
C++

#include <bits/stdc++.h>
using namespace std;

int n = 1260;
int cnt;

int cointype[4] = {500,100,50,10};

int main(void) {
    for (int i=0; i<4; i++){
        cont += n/cointype[i];
        n %= cointype[i];
    }
    count << cnt << '\n';
}
'''






































